<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>La ricorsione | Informatica insieme</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="La ricorsione" />
<meta name="author" content="fabio" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Problema: devo lavare una pila di 15 piatti. Soluzione:" />
<meta property="og:description" content="Problema: devo lavare una pila di 15 piatti. Soluzione:" />
<link rel="canonical" href="http://localhost:4000/informaticainsieme/python/la-ricorsione" />
<meta property="og:url" content="http://localhost:4000/informaticainsieme/python/la-ricorsione" />
<meta property="og:site_name" content="Informatica insieme" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-02-04T15:45:02+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="La ricorsione" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"fabio"},"dateModified":"2020-02-04T15:45:02+01:00","datePublished":"2020-02-04T15:45:02+01:00","description":"Problema: devo lavare una pila di 15 piatti. Soluzione:","headline":"La ricorsione","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/informaticainsieme/python/la-ricorsione"},"url":"http://localhost:4000/informaticainsieme/python/la-ricorsione"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/informaticainsieme/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/informaticainsieme/feed.xml" title="Informatica insieme" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/informaticainsieme/">Informatica insieme</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/informaticainsieme/about/">About me</a><a class="page-link" href="/informaticainsieme/paginemenu/codifica.html">La codifica dell&#39;informazione</a><a class="page-link" href="/informaticainsieme/paginemenu/python.html">Python</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">La ricorsione</h1>
  </header>

  <div class="post-content">
    <p>Problema: devo lavare una pila di 15 piatti. <br />
Soluzione:</p>

<ul>
  <li>lavo un piatto;</li>
  <li>devo lavare 14 piatti.</li>
</ul>

<p>Sembra un ragionamento banale ma il suo scopo è quello di sottolineare come un problema possa essere scomposto utilizzando la sua stessa definizione. Il problema devo lavare 15 piatti viene scomposto nel problema lavo un piatto e devo lavare 14 piatti. Generalizzando possiamo scrivere che devo lavare n piatti viene scomposto nel problema lavo un piatto e devo lavare n – 1 piatti.</p>

<p>La ricorsione (in inglese recursion) è una tecnica di programmazione molto potente che sfrutta l’idea di lavorare sulla definizione stessa del problema che stiamo risolvendo al fine di risolverlo attraverso l’algoritmo più semplice che si possa immaginare. Contrariamente a quanto si possa intuitivamente pensare, scrivere algoritmi semplici è estremante complesso, molti programmatori professionisti non sono in grado di applicare questa tecnica.</p>

<h4 id="ragioniamo-con-i-numeri">Ragioniamo con i numeri</h4>

<p>Supponiamo di voler calcolare la somma dei primi n numeri interi. Quello che facciamo consiste nel lavorare sulla definizione stessa del problema. Ragioniamo sui numeri, calcoliamo la somma dei primi 4 numeri interi: <em>1 + 2 + 3 + 4 = 10</em></p>

<p>Se immaginiamo di aver definito una funzione <em>sommainteri(n)</em> dove n rappresenta il numero di interi da sommare, possiamo scrivere:</p>

<p><em>sommainteri(4) = 1 + 2 + 3 + 4 = 10</em></p>

<p>Ma questo equivale a scrivere:</p>

<p><em>(1 + 2 + 3) + 4 = sommainteri(3) + 4</em></p>

<p>Come abbiamo ragionato? Abbiamo lavorato sulla definizione stessa della funzione decomponendola in due parti:</p>

<p><em>sommainteri(n) = sommainteri(n − 1) + n</em></p>

<p>Questa relazione è valida fintantoché n &gt; 0. Parafrasando in Python:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">sommainteri</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">sommainteri</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></code></pre></figure>

<p>&lt;/div&gt;La soluzione appena trovata presenta un aspetto interessante: per risolvere il problema ci siamo basati sul poter risolvere lo stesso problema per un numero più piccolo. Questo approccio viene definito ricorsivo.</p>

<p>Un algoritmo ricorsivo per la risoluzione di un dato problema deve essere definito nel modo seguente:</p>

<ul>
  <li>passo base: si definisce come risolvere il problema quando questo ha dimensione minima e può essere risolto in maniera estremamente semplice;</li>
  <li>passo ricorsivo: si definisce come ottenere la soluzione del problema come composizione di un problema analogo ma di dimensione inferiore e una operazione semplice.</li>
</ul>

<h4 id="ricorsione-diretta">Ricorsione Diretta</h4>

<p>Una funzione si dice ricorsiva quando all’interno della propria definizione compare una chiamata diretta a se stessa. Questa forma di ricorsione si chiama ricorsione diretta.</p>

<p>Un esempio di ricorsione diretta è la funzione per calcolare il fattoriale di un numero n:</p>

<p>Osserviamo che:</p>

<p><em>n! = n ∗ (n − 1) ∗ … ∗ 2 ∗ 1 = n ∗ (n − 1)!</em></p>

<p>Quindi la definizione induttiva del fattoriale è:</p>

<ul>
  <li>(passo base) 0! = 1</li>
  <li>(passoricorsivo)n!=n∗(n−1)!(sen&gt;0).</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">fattoriale</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> 
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fattoriale</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></code></pre></figure>

<p>&lt;/div&gt;Condizioni come (n == 1) si chiamano clausole di chiusura perché garantiscono che la ricorsione termini.</p>

<p>Esistono due requisiti che sono basilari per essere sicuri che la ricorsione funzioni:</p>

<ul>
  <li>ogni invocazione ricorsiva deve semplificare in qualche modo l’elaborazione;</li>
  <li>devono esistere casi speciali che gestiscano in modo diretto le elaborazioni più semplici.</li>
</ul>

<p>Occorre però fare molta attenzione: cosa succede se si calcola il fattoriale di -1? La clausola di chiusura non sarebbe mai verificata e il sistema andrebbe in un loop infinito. Per evitare che ciò accada facciamo una piccola modifica.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">fattoriale</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> 
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Errore nell'input"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fattoriale</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></code></pre></figure>

<p>&lt;/div&gt;In questo modo la funzione fattoriale riesce sempre a concludere la propria elaborazione.</p>

<h4 id="ricorsione-indiretta">Ricorsione indiretta</h4>

<p>Si parla di ricorsione indiretta quando nella definizione di un metodo compare la chiamata ad un altro metodo il quale direttamente o indirettamente chiama il metodo iniziale.</p>

<p>Un esempio di ricorsione indiretta</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">numero_pari</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> 
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">numero_dispari</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> 

<span class="k">def</span> <span class="nf">numero_dispari</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">numero_pari</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></code></pre></figure>

<p>&lt;/div&gt;Possiamo notare come la funzione numero_pari abbia al suo interno la clausola di chiusura e la chiamata alla funzione numero_dispari. Quest’ultima ha al suo interno la chiamata alla funzione numero_pari.</p>

<h4 id="ricorsione-multipla">Ricorsione Multipla</h4>

<p>Una funzione implementa una ricorsione multipla quando al suo interno compare, almeno due volte, la chiamata a se stessa.</p>

<p>Un classico esempio di ricorsione multipla è l’implementazione dei numeri di Fibonacci, la cui definizione è riportata sotto:</p>

<ul>
  <li>fib(0)=0</li>
  <li>fib(1)=1</li>
  <li>fib(n)=fib(n−1)+fib(n−2) (se n&gt;1)</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Errore nell'input"</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> 
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span></code></pre></figure>

<p>&lt;/div&gt;Notare che, come per il fattoriale, la funzione è definita solo su interi non negativi.</p>

<h4 id="la-ricorsione-e-le-liste">La ricorsione e le liste</h4>

<p>È possibile utilizzare algoritmi ricorsivi per operare sulle liste. Se per esempio volessimo sommare tutti gli i numeri contenuti in una lista potremmo operare nel seguente modo:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">numeri</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">s_lista</span><span class="p">(</span><span class="n">lista</span><span class="p">):</span> 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lista</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lista</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s_lista</span><span class="p">(</span><span class="n">lista</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span></code></pre></figure>

<p>&lt;/div&gt;- passo base: se la lista è vuota la somma dei numeri al suo interno è 0;</p>
<ul>
  <li>passo ricorsivo: se la lista non è vuota la somma dei numeri al suo interno è pari al primo numero in lista cui va sommata il risultato della somma della sottolista ottenuta togliendo alla lista il primo numero.</li>
</ul>

<p>Dato che una stringa altro non è che una lista di caratteri, è possibile operare su questa allo stesso modo.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">string</span><span class="p">):</span> 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">string</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reverse</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></code></pre></figure>

<p>&lt;/div&gt;### Esercizi</p>

<p><strong>Esercizio 1:</strong></p>

<p>Scrivere una funzione ricorsiva che controlli se una stringa è palindroma (ovvero se “rigirandola” non cambia, es. “ossesso” è palindroma).</p>

<p>Esempi di frasi palindrome:</p>

<p>I verbi brevi (“iverbibrevi”) Aceto nell’enoteca (“acetonellenoteca”) I topi non avevano nipoti (“itopinonavevanonipoti”)</p>

<p>Definizione ricorsiva di palindromicità:</p>

<ul>
  <li>Una stringa nulla è palindroma. Esempio: “”.</li>
  <li>Una stringa di un carattere è palindroma. Esempio: “a”.</li>
  <li>Una stringa aventi il primo e l’ultimo carattere uguali e la sottostringa nel mezzo è palindroma, è palindroma. Esempio: “ossesso”.</li>
</ul>

<p><strong>Esercizio 2:</strong></p>

<p>Scrivere una funzione ricorsiva che analizzando una stringa in modo ricorsivo ne estragga, scrivendole in output (print), le sole lettere vocali.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">analizzanda</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Digita la stringa da analizzare: "</span><span class="p">)</span>
<span class="n">vocali</span> <span class="o">=</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">,</span> <span class="s">'i'</span><span class="p">,</span> <span class="s">'o'</span><span class="p">,</span> <span class="s">'u'</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">estrai_vocali</span><span class="p">(</span><span class="n">analizzanda</span><span class="p">,</span> <span class="n">vocali</span><span class="p">):</span>
    <span class="k">pass</span>
    <span class="c1"># scrivi tu questa funzione</span></code></pre></figure>

<p>&lt;/div&gt;<strong>Esercizio 3:</strong></p>

<p>Scrivere una funzione ricorsiva che calcoli la somma dei cifre contenute in un numero. Es. f(325) = 10</p>

<p>Soluzione: <br />
 (Caso Base) Se le cifre sono finite allora la somma delle sue cifre è zero <br />
 (Passo generico) Se il numero è composto da tante cifre allora la somma delle sue cifre è data dalla somma della prima cifra più la somma delle cifre seguenti.</p>

<p><strong>Esercizio 4:</strong></p>

<p>Creare una funzione ricorsiva per calcolare una funzione definita così:<br />
 per m&gt;0 allora f(n,m) = 1+f(n,m-1)<br />
 per m=0 allora f(n,m) = n<br />
 Una volta implementata, provarla e dire cosa calcola la funzione.</p>

<p><strong>Esercizio 5:</strong></p>

<p>Scrivere il codice di una funzione ricorsiva f(n) che restituisce 0 nel caso n sia dispari, 1+f(n/2) altrimenti.</p>

<p><strong>Esercizio 6:</strong></p>

<p>Scrivere il codice di una funzione ricorsiva int f(int n) che restituisce quante coppie di cifre uguali in posizioni adiacenti ci sono nel numero n, nel caso n sia negativo restituisce 0.<br />
<em>Ad es: f(551122) restituisce 3, f(5122) restituisce 1, f(9) restituisce 0.</em></p>

<p><strong>Esercizio 7:</strong></p>

<p>Scrivere una funzione ricorsiva POT(n) per il calcolo dei numeri F(n) definiti dalle seguenti relazioni:</p>

<p>F(1) = 2 <br />
F(n)=2F(n−1) n≥2</p>

<p><strong>Esercizio 7:</strong></p>

<p>Scrivere una funzione ricorsiva che, avendo in input una lista di n interi, dia in output il numero degli elementi positivi della lista.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/informaticainsieme/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Informatica insieme</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Informatica insieme</li><li><a class="u-email" href="mailto:burattino@gmail.com">burattino@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/fabiomattei"><svg class="svg-icon"><use xlink:href="/informaticainsieme/assets/minima-social-icons.svg#github"></use></svg> <span class="username">fabiomattei</span></a></li><li><a href="https://www.twitter.com/fabiomattei"><svg class="svg-icon"><use xlink:href="/informaticainsieme/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">fabiomattei</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>fare cosa gradita.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
